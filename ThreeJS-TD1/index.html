<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Three.js - Exercice 1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        Three.js Scene - Exercice 1<br>
        Bougez votre smartphone pour contrôler la rotation<br>
        Les objets restent statiques quand le téléphone est à plat
    </div>

    <div id="container"></div>

    <div id="controls">
        Appuyez sur 'R' pour réinitialiser la rotation
    </div>

    <!-- Three.js CDN - dernière version -->
    <script src="https://unpkg.com/three@0.156.1/build/three.min.js"></script>
    <!-- GLTFLoader pour les modèles 3D -->
    <script src="https://unpkg.com/three@0.156.1/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Variables globales
        let scene, camera, renderer;
        let cube, sphere, torus, loadedModel;
        let ambientLight, directionalLight;
        let textureLoader, gltfLoader;

        // Variables d'animation
        let rotationX = 0;
        let rotationY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let isDeviceFlat = true;
        let lastBeta = 0;
        let lastGamma = 0;

        // Variables pour les particules
        let particleSystem;

        // Initialisation
        init();
        animate();

        function init() {
            // Conteneur
            const container = document.getElementById('container');

            // Scène
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 1000);

            // Caméra
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x111111);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Éclairage
            ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Chargeurs
            textureLoader = new THREE.TextureLoader();

            // Créer les objets
            createCube();
            createSphere();
            createTorus();
            createParticles();

            // Charger un modèle 3D (optionnel)
            loadModel();

            // Événements
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);

            // Device orientation pour smartphone
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', onDeviceOrientation);
            }

            // Device motion (optionnel)
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', onDeviceMotion);
            }
        }

        function createCube() {
            // Géométrie du cube
            const geometry = new THREE.BoxGeometry(1, 1, 1);

            // Texture pour le cube
            const texture = textureLoader.load('content.png');

            // Matériau avec texture
            const material = new THREE.MeshPhongMaterial({
                color: 0x00ff00,
                map: texture,
                shininess: 100
            });

            // Créer le cube
            cube = new THREE.Mesh(geometry, material);
            cube.position.x = -2;
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
        }

        function createSphere() {
            // Géométrie de la sphère
            const geometry = new THREE.SphereGeometry(0.8, 32, 32);

            // Charger texture de la Terre
            const earthTexture = textureLoader.load(
                'https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/planets/earth_atmos_2048.jpg',
                function(texture) {
                    console.log('Texture Terre chargée');
                },
                function(progress) {
                    console.log('Chargement texture Terre:', progress);
                },
                function(error) {
                    console.log('Erreur texture Terre, utilisation couleur de base');
                }
            );

            // Matériau avec texture de la Terre
            const material = new THREE.MeshPhongMaterial({
                map: earthTexture,
                color: 0x4488ff,
                shininess: 100,
                specular: 0x111111
            });

            // Créer la sphère
            sphere = new THREE.Mesh(geometry, material);
            sphere.position.x = 2;
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            scene.add(sphere);
        }

        function createTorus() {
            // Géométrie du tore
            const geometry = new THREE.TorusGeometry(0.8, 0.3, 16, 100);

            // Matériau avec couleur métallique
            const material = new THREE.MeshPhongMaterial({
                color: 0x9932cc,
                shininess: 150,
                specular: 0x444444
            });

            // Créer le tore
            torus = new THREE.Mesh(geometry, material);
            torus.position.set(0, -2, 0);
            torus.castShadow = true;
            torus.receiveShadow = true;
            scene.add(torus);
        }

        function createParticles() {
            // Système de particules simple
            const particles = new THREE.BufferGeometry();
            const particleCount = 1000;

            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 20;     // x
                positions[i + 1] = (Math.random() - 0.5) * 20; // y
                positions[i + 2] = (Math.random() - 0.5) * 20; // z
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.6
            });

            particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }

        function loadModel() {
            // Pour charger un modèle glTF (vous devrez ajouter un fichier .gltf)
            // Exemple avec un modèle simple - remplacez par votre propre modèle
            /*
            gltfLoader = new THREE.GLTFLoader();
            gltfLoader.load(
                'models/scene.gltf', // Remplacez par le chemin de votre modèle
                function(gltf) {
                    loadedModel = gltf.scene;
                    loadedModel.position.y = -1;
                    loadedModel.scale.set(0.5, 0.5, 0.5);
                    scene.add(loadedModel);
                },
                function(progress) {
                    console.log('Progression du modèle:', (progress.loaded / progress.total * 100) + '%');
                },
                function(error) {
                    console.error('Erreur de chargement du modèle:', error);
                }
            );
            */
        }

        function onDeviceOrientation(event) {
            // Vérifier si le téléphone est relativement à plat
            if (event.gamma !== null && event.beta !== null) {
                const beta = event.beta;  // inclinaison avant/arrière (-180 à 180)
                const gamma = event.gamma; // inclinaison gauche/droite (-90 à 90)

                // Seuil pour déterminer si le téléphone est à plat (en degrés)
                const flatThreshold = 10;

                // Vérifier si le téléphone est proche de la position horizontale
                const isFlatNow = Math.abs(beta) < flatThreshold && Math.abs(gamma) < flatThreshold;

                // Détecter le mouvement (changement significatif d'orientation)
                const movementThreshold = 2;
                const hasMovement = Math.abs(beta - lastBeta) > movementThreshold ||
                                  Math.abs(gamma - lastGamma) > movementThreshold;

                // Mettre à jour les valeurs de référence
                lastBeta = beta;
                lastGamma = gamma;

                // Si le téléphone est à plat et sans mouvement, arrêter la rotation
                if (isFlatNow && !hasMovement) {
                    isDeviceFlat = true;
                    // Ralentir progressivement la rotation vers zéro
                    targetRotationX *= 0.95;
                    targetRotationY *= 0.95;
                } else {
                    isDeviceFlat = false;
                    // Appliquer la rotation basée sur l'orientation
                    targetRotationY = gamma * 0.01;  // rotation gauche/droite
                    targetRotationX = beta * 0.01;   // rotation haut/bas
                }
            }
        }

        function onDeviceMotion(event) {
            // Optionnel: utiliser l'accélération pour des effets supplémentaires
            if (event.acceleration) {
                // Exemple: faire bouger les particules selon l'accélération
                if (particleSystem) {
                    const positions = particleSystem.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += (event.acceleration.x || 0) * 0.001;
                        positions[i + 1] += (event.acceleration.y || 0) * 0.001;
                    }
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                }
            }
        }

        function onKeyDown(event) {
            switch(event.code) {
                case 'KeyR':
                    // Réinitialiser la rotation
                    targetRotationX = 0;
                    targetRotationY = 0;
                    break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            // Animation continue
            renderer.setAnimationLoop(render);
        }

        function render() {
            // Interpolation douce des rotations
            rotationX += (targetRotationX - rotationX) * 0.05;
            rotationY += (targetRotationY - rotationY) * 0.05;

            // Rotation seulement si le téléphone bouge
            if (cube) {
                if (!isDeviceFlat) {
                    cube.rotation.x += rotationX;
                    cube.rotation.y += rotationY;
                }
            }

            if (sphere) {
                if (!isDeviceFlat) {
                    sphere.rotation.x += rotationX * 0.5;
                    sphere.rotation.y += rotationY * 0.5;
                }
            }

            if (torus) {
                if (!isDeviceFlat) {
                    torus.rotation.x += rotationX * 0.3;
                    torus.rotation.z += rotationY * 0.7;
                }
            }

            // Animation des particules
            if (particleSystem) {
                particleSystem.rotation.x += 0.001;
                particleSystem.rotation.y += 0.002;
            }

            // Animation du modèle chargé (si présent)
            if (loadedModel) {
                loadedModel.rotation.y += 0.005;
            }

            // Rendu
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>