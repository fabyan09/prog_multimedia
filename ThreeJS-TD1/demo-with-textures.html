<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Three.js - Démo avec Textures</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">
        Three.js - Démo avec Textures<br>
        <small>Cube: Texture procédurale damier</small><br>
        <small>Sphère: Texture UV mapping</small><br>
        <small>Plan: Texture répétée</small>
    </div>

    <div id="container"></div>

    <div id="controls">
        Contrôles:<br>
        • Clic gauche + glisser: Orbiter<br>
        • Molette: Zoom<br>
        • R: Réinitialiser rotation smartphone
    </div>

    <!-- Three.js CDN -->
    <script src="https://unpkg.com/three@0.156.1/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.156.1/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Variables globales
        let scene, camera, renderer, controls;
        let cube, sphere, ground;
        let ambientLight, directionalLight, pointLight;
        let textureLoader;

        // Variables pour les effets
        let particleSystem;
        let fog;

        // Variables d'animation
        let time = 0;

        // Variables smartphone
        let deviceRotationX = 0;
        let deviceRotationY = 0;

        // Initialisation
        init();
        animate();

        function init() {
            const container = document.getElementById('container');

            // Scène
            scene = new THREE.Scene();

            // Fog atmosphérique
            scene.fog = new THREE.Fog(0x222222, 1, 100);

            // Caméra
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x222222);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Contrôles orbit (pour desktop)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Chargeur de textures
            textureLoader = new THREE.TextureLoader();

            // Éclairage
            setupLighting();

            // Créer les objets avec textures
            createTexturedObjects();
            createParticleEffect();

            // Événements
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);

            // Device orientation pour smartphone
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', onDeviceOrientation);
            }
        }

        function setupLighting() {
            // Lumière ambiante
            ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Lumière directionnelle (soleil)
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);

            // Lumière ponctuelle colorée
            pointLight = new THREE.PointLight(0x00ffff, 0.5, 50);
            pointLight.position.set(0, 5, 0);
            scene.add(pointLight);
        }

        function createTexturedObjects() {
            // 1. CUBE avec texture damier procédurale
            const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);

            // Créer une texture damier procédurale
            const checkerTexture = createCheckerTexture(256, 256, 32);
            checkerTexture.wrapS = THREE.RepeatWrapping;
            checkerTexture.wrapT = THREE.RepeatWrapping;
            checkerTexture.repeat.set(2, 2);

            const cubeMaterial = new THREE.MeshPhongMaterial({
                map: checkerTexture,
                shininess: 100
            });

            cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(-3, 1, 0);
            cube.castShadow = true;
            scene.add(cube);

            // 2. SPHÈRE avec texture UV mapping
            const sphereGeometry = new THREE.SphereGeometry(1.5, 32, 32);

            // Créer une texture UV pour visualiser le mapping
            const uvTexture = createUVTexture(512, 512);

            const sphereMaterial = new THREE.MeshPhongMaterial({
                map: uvTexture,
                shininess: 50
            });

            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(3, 1, 0);
            sphere.castShadow = true;
            scene.add(sphere);

            // 3. PLAN avec texture répétée
            const groundGeometry = new THREE.PlaneGeometry(20, 20);

            // Créer une texture de carrelage
            const tileTexture = createTileTexture(128, 128);
            tileTexture.wrapS = THREE.RepeatWrapping;
            tileTexture.wrapT = THREE.RepeatWrapping;
            tileTexture.repeat.set(10, 10);

            const groundMaterial = new THREE.MeshLambertMaterial({
                map: tileTexture
            });

            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createCheckerTexture(width, height, checkSize) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            const checksX = width / checkSize;
            const checksY = height / checkSize;

            for (let i = 0; i < checksX; i++) {
                for (let j = 0; j < checksY; j++) {
                    const isEven = (i + j) % 2;
                    ctx.fillStyle = isEven ? '#ffffff' : '#000000';
                    ctx.fillRect(i * checkSize, j * checkSize, checkSize, checkSize);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.generateMipmaps = false;
            texture.minFilter = THREE.LinearFilter;
            return texture;
        }

        function createUVTexture(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // Gradient horizontal (U)
            const gradientU = ctx.createLinearGradient(0, 0, width, 0);
            gradientU.addColorStop(0, '#ff0000');
            gradientU.addColorStop(1, '#00ff00');

            // Gradient vertical (V)
            const gradientV = ctx.createLinearGradient(0, 0, 0, height);
            gradientV.addColorStop(0, '#0000ff');
            gradientV.addColorStop(1, '#ffff00');

            // Appliquer les gradients
            ctx.fillStyle = gradientU;
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = gradientV;
            ctx.fillRect(0, 0, width, height);

            // Ajouter une grille pour visualiser les coordonnées UV
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;

            const gridSize = width / 8;
            for (let i = 0; i <= 8; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(width, i * gridSize);
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createTileTexture(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // Fond gris clair
            ctx.fillStyle = '#cccccc';
            ctx.fillRect(0, 0, width, height);

            // Bordures plus foncées pour simuler les joints
            ctx.strokeStyle = '#888888';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, width, height);

            // Motif central
            ctx.fillStyle = '#aaaaaa';
            ctx.fillRect(width * 0.1, height * 0.1, width * 0.8, height * 0.8);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createParticleEffect() {
            const particleCount = 500;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                // Position aléatoire
                positions[i3] = (Math.random() - 0.5) * 30;
                positions[i3 + 1] = Math.random() * 20;
                positions[i3 + 2] = (Math.random() - 0.5) * 30;

                // Couleur aléatoire
                colors[i3] = Math.random();
                colors[i3 + 1] = Math.random();
                colors[i3 + 2] = Math.random();
            }

            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.7
            });

            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
        }

        function onDeviceOrientation(event) {
            if (event.gamma !== null && event.beta !== null) {
                deviceRotationX = event.beta * 0.01;
                deviceRotationY = event.gamma * 0.01;

                // Désactiver les contrôles orbit quand on utilise le smartphone
                controls.enabled = false;
            }
        }

        function onKeyDown(event) {
            switch(event.code) {
                case 'KeyR':
                    deviceRotationX = 0;
                    deviceRotationY = 0;
                    controls.enabled = true;
                    controls.reset();
                    break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            time += 0.01;

            // Animation des objets
            if (cube) {
                cube.rotation.x += 0.01 + deviceRotationX * 0.1;
                cube.rotation.y += 0.01 + deviceRotationY * 0.1;
            }

            if (sphere) {
                sphere.rotation.x += 0.005;
                sphere.rotation.y += 0.02;
                sphere.position.y = 1 + Math.sin(time) * 0.3;
            }

            // Animation des particules
            if (particleSystem) {
                particleSystem.rotation.y += 0.001;

                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= 0.02; // Chute des particules
                    if (positions[i] < -10) {
                        positions[i] = 20; // Reset en haut
                    }
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }

            // Animation de la lumière ponctuelle
            if (pointLight) {
                pointLight.position.x = Math.sin(time) * 5;
                pointLight.position.z = Math.cos(time) * 5;
            }

            // Mise à jour des contrôles
            controls.update();

            // Appliquer la rotation du smartphone à la caméra si activée
            if (!controls.enabled) {
                camera.position.x = 5 * Math.cos(deviceRotationY);
                camera.position.z = 5 * Math.sin(deviceRotationY);
                camera.position.y = 5 + deviceRotationX * 3;
                camera.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>