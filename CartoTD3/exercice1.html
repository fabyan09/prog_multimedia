<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Exercice 1 - Géolocalisation 3D + Leaflet</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        #leaflet-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 350px;
            height: 300px;
            z-index: 1000;
            border: 3px solid #fff;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        #map {
            width: 100%;
            height: 100%;
            border-radius: 5px;
        }

        #info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            max-width: 280px;
            z-index: 1000;
            font-size: 12px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 2000;
            text-align: center;
        }

        /* Responsive design pour mobile */
        @media (max-width: 768px) {
            #leaflet-container {
                width: calc(100vw - 20px);
                max-width: 300px;
                height: 200px;
                top: 10px;
                left: 10px;
            }

            #info {
                bottom: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
                font-size: 11px;
                padding: 8px;
            }

            #loading {
                width: 80%;
                max-width: 300px;
                padding: 15px;
            }

            #loading h2 {
                font-size: 1.2em;
                margin: 5px 0;
            }

            #loading p {
                font-size: 0.9em;
                margin: 5px 0;
            }
        }

        @media (max-width: 480px) {
            #leaflet-container {
                width: calc(100vw - 20px);
                max-width: 250px;
                height: 180px;
            }

            #info {
                font-size: 10px;
            }

            .desktop-only {
                display: none !important;
            }

            .mobile-only {
                display: inline !important;
            }
        }
    </style>

    <!-- Babylon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
    <div id="loading">
        <h2>Chargement...</h2>
        <p>Récupération des données des pays</p>
    </div>

    <div id="leaflet-container">
        <div id="map"></div>
    </div>

    <div id="info">
        <strong>Instructions:</strong><br>
        <span class="desktop-only">• Cliquez sur un pays pour recentrer Leaflet<br>
        • Cliquez sur Leaflet pour orienter la Terre<br>
        • Utilisez la souris pour pivoter</span>
        <span class="mobile-only" style="display:none;">• Touchez un pays ou la carte<br>
        • Glissez pour pivoter la Terre</span>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);
        const loadingDiv = document.getElementById('loading');
        const infoDiv = document.getElementById('info');

        let scene = null;
        let earth = null;
        let camera = null;
        let leafletMap = null;
        let userPosition = { lat: 48.8566, lon: 2.3522 }; // Paris par défaut
        let countries = [];
        let countryMarkers = [];
        let userMarker3D = null;

        // ========== CONVERSION LAT/LON <-> XYZ ==========

        /**
         * Convertit les coordonnées géographiques (lat, lon) en coordonnées cartésiennes (x, y, z)
         * sur une sphère de rayon donné
         * Avec uScale=-1 sur la texture, on doit inverser la longitude
         * @param {number} lat - Latitude en degrés
         * @param {number} lon - Longitude en degrés
         * @param {number} radius - Rayon de la sphère
         * @returns {object} - {x, y, z}
         */
        function latLonToCartesian(lat, lon, radius = 1) {
            const phi = (90 - lat) * Math.PI / 180; // latitude -> phi (de 0 à PI)
            // Décaler de 180° et inverser la longitude car uScale = -1 sur la texture
            const theta = (-(lon + 180) + 180) * Math.PI / 180; // longitude décalée et inversée
            // Simplifié: theta = (-lon) * Math.PI / 180

            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);

            return { x, y, z };
        }

        /**
         * Convertit des coordonnées cartésiennes en coordonnées géographiques
         * Fonction inverse EXACTE de latLonToCartesian
         * @param {number} x
         * @param {number} y
         * @param {number} z
         * @param {number} radius - Rayon de la sphère
         * @returns {object} - {lat, lon}
         */
        function cartesianToLatLon(x, y, z, radius = 1) {
            const phi = Math.acos(y / radius);
            const theta = Math.atan2(z, -x);

            const lat = 90 - (phi * 180 / Math.PI);
            // Inverse de: theta = (-lon) * PI / 180
            const thetaDeg = theta * 180 / Math.PI;
            const lon = -thetaDeg;

            return { lat, lon };
        }

        // ========== INITIALISATION LEAFLET ==========

        function initLeaflet() {
            leafletMap = L.map('map').setView([userPosition.lat, userPosition.lon], 3);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(leafletMap);

            // Marqueur utilisateur sur Leaflet
            const userLeafletMarker = L.marker([userPosition.lat, userPosition.lon], {
                title: 'Votre position'
            }).addTo(leafletMap);
            userLeafletMarker.bindPopup('<b>Votre position</b>').openPopup();

            // Clic sur la carte Leaflet -> Rotation de la Terre 3D
            leafletMap.on('click', function(e) {
                const clickedLat = e.latlng.lat;
                const clickedLon = e.latlng.lng;

                // Orienter la Terre pour que le point cliqué soit face à la caméra
                rotateCameraToPoint(clickedLat, clickedLon);

                // Ajouter un marqueur temporaire
                L.marker([clickedLat, clickedLon])
                    .addTo(leafletMap)
                    .bindPopup(`Lat: ${clickedLat.toFixed(2)}, Lon: ${clickedLon.toFixed(2)}`)
                    .openPopup();
            });
        }

        // ========== RÉCUPÉRATION DES PAYS ==========

        async function fetchCountries() {
            try {
                console.log('Tentative de récupération des pays depuis restcountries.com...');
                const response = await fetch('https://restcountries.com/v3.1/all?fields=name,latlng,flags');

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Données reçues:', data);

                // Vérifier que data est un tableau
                if (!Array.isArray(data)) {
                    console.error('Les données reçues ne sont pas un tableau:', data);
                    throw new Error('Format de données incorrect');
                }

                // Filtrer les pays qui ont des coordonnées et un drapeau
                countries = data.filter(country =>
                    country.latlng &&
                    country.latlng.length === 2 &&
                    country.flags &&
                    country.flags.png
                ).map(country => ({
                    name: country.name.common,
                    lat: country.latlng[0],
                    lon: country.latlng[1],
                    flag: country.flags.png,
                    code: country.cca2
                }));

                // Charger TOUS les pays
                console.log(`${countries.length} pays chargés avec succès`);
                console.log('Exemple de pays:', countries[0]); // Debug
                return countries;
            } catch (error) {
                console.error('Erreur lors du chargement des pays:', error);
                console.log('Utilisation de la liste de pays par défaut...');

                // Liste de pays par défaut en cas d'échec de l'API
                countries = [
                    { name: 'France', lat: 46.2276, lon: 2.2137, flag: 'https://flagcdn.com/w320/fr.png', code: 'FR' },
                    { name: 'Germany', lat: 51.1657, lon: 10.4515, flag: 'https://flagcdn.com/w320/de.png', code: 'DE' },
                    { name: 'Italy', lat: 41.8719, lon: 12.5674, flag: 'https://flagcdn.com/w320/it.png', code: 'IT' },
                    { name: 'Spain', lat: 40.4637, lon: -3.7492, flag: 'https://flagcdn.com/w320/es.png', code: 'ES' },
                    { name: 'United Kingdom', lat: 55.3781, lon: -3.4360, flag: 'https://flagcdn.com/w320/gb.png', code: 'GB' },
                    { name: 'United States', lat: 37.0902, lon: -95.7129, flag: 'https://flagcdn.com/w320/us.png', code: 'US' },
                    { name: 'Canada', lat: 56.1304, lon: -106.3468, flag: 'https://flagcdn.com/w320/ca.png', code: 'CA' },
                    { name: 'Brazil', lat: -14.2350, lon: -51.9253, flag: 'https://flagcdn.com/w320/br.png', code: 'BR' },
                    { name: 'Argentina', lat: -38.4161, lon: -63.6167, flag: 'https://flagcdn.com/w320/ar.png', code: 'AR' },
                    { name: 'Mexico', lat: 23.6345, lon: -102.5528, flag: 'https://flagcdn.com/w320/mx.png', code: 'MX' },
                    { name: 'Japan', lat: 36.2048, lon: 138.2529, flag: 'https://flagcdn.com/w320/jp.png', code: 'JP' },
                    { name: 'China', lat: 35.8617, lon: 104.1954, flag: 'https://flagcdn.com/w320/cn.png', code: 'CN' },
                    { name: 'India', lat: 20.5937, lon: 78.9629, flag: 'https://flagcdn.com/w320/in.png', code: 'IN' },
                    { name: 'Australia', lat: -25.2744, lon: 133.7751, flag: 'https://flagcdn.com/w320/au.png', code: 'AU' },
                    { name: 'Russia', lat: 61.5240, lon: 105.3188, flag: 'https://flagcdn.com/w320/ru.png', code: 'RU' },
                    { name: 'South Africa', lat: -30.5595, lon: 22.9375, flag: 'https://flagcdn.com/w320/za.png', code: 'ZA' },
                    { name: 'Egypt', lat: 26.8206, lon: 30.8025, flag: 'https://flagcdn.com/w320/eg.png', code: 'EG' },
                    { name: 'Nigeria', lat: 9.0820, lon: 8.6753, flag: 'https://flagcdn.com/w320/ng.png', code: 'NG' },
                    { name: 'Kenya', lat: -0.0236, lon: 37.9062, flag: 'https://flagcdn.com/w320/ke.png', code: 'KE' },
                    { name: 'Morocco', lat: 31.7917, lon: -7.0926, flag: 'https://flagcdn.com/w320/ma.png', code: 'MA' },
                    { name: 'Turkey', lat: 38.9637, lon: 35.2433, flag: 'https://flagcdn.com/w320/tr.png', code: 'TR' },
                    { name: 'Saudi Arabia', lat: 23.8859, lon: 45.0792, flag: 'https://flagcdn.com/w320/sa.png', code: 'SA' },
                    { name: 'UAE', lat: 23.4241, lon: 53.8478, flag: 'https://flagcdn.com/w320/ae.png', code: 'AE' },
                    { name: 'South Korea', lat: 35.9078, lon: 127.7669, flag: 'https://flagcdn.com/w320/kr.png', code: 'KR' },
                    { name: 'Thailand', lat: 15.8700, lon: 100.9925, flag: 'https://flagcdn.com/w320/th.png', code: 'TH' },
                    { name: 'Vietnam', lat: 14.0583, lon: 108.2772, flag: 'https://flagcdn.com/w320/vn.png', code: 'VN' },
                    { name: 'Indonesia', lat: -0.7893, lon: 113.9213, flag: 'https://flagcdn.com/w320/id.png', code: 'ID' },
                    { name: 'Philippines', lat: 12.8797, lon: 121.7740, flag: 'https://flagcdn.com/w320/ph.png', code: 'PH' },
                    { name: 'New Zealand', lat: -40.9006, lon: 174.8860, flag: 'https://flagcdn.com/w320/nz.png', code: 'NZ' },
                    { name: 'Chile', lat: -35.6751, lon: -71.5430, flag: 'https://flagcdn.com/w320/cl.png', code: 'CL' },
                    { name: 'Peru', lat: -9.1900, lon: -75.0152, flag: 'https://flagcdn.com/w320/pe.png', code: 'PE' },
                    { name: 'Colombia', lat: 4.5709, lon: -74.2973, flag: 'https://flagcdn.com/w320/co.png', code: 'CO' },
                    { name: 'Venezuela', lat: 6.4238, lon: -66.5897, flag: 'https://flagcdn.com/w320/ve.png', code: 'VE' },
                    { name: 'Poland', lat: 51.9194, lon: 19.1451, flag: 'https://flagcdn.com/w320/pl.png', code: 'PL' },
                    { name: 'Netherlands', lat: 52.1326, lon: 5.2913, flag: 'https://flagcdn.com/w320/nl.png', code: 'NL' },
                    { name: 'Belgium', lat: 50.5039, lon: 4.4699, flag: 'https://flagcdn.com/w320/be.png', code: 'BE' },
                    { name: 'Switzerland', lat: 46.8182, lon: 8.2275, flag: 'https://flagcdn.com/w320/ch.png', code: 'CH' },
                    { name: 'Austria', lat: 47.5162, lon: 14.5501, flag: 'https://flagcdn.com/w320/at.png', code: 'AT' },
                    { name: 'Sweden', lat: 60.1282, lon: 18.6435, flag: 'https://flagcdn.com/w320/se.png', code: 'SE' },
                    { name: 'Norway', lat: 60.4720, lon: 8.4689, flag: 'https://flagcdn.com/w320/no.png', code: 'NO' },
                    { name: 'Denmark', lat: 56.2639, lon: 9.5018, flag: 'https://flagcdn.com/w320/dk.png', code: 'DK' },
                    { name: 'Finland', lat: 61.9241, lon: 25.7482, flag: 'https://flagcdn.com/w320/fi.png', code: 'FI' },
                    { name: 'Portugal', lat: 39.3999, lon: -8.2245, flag: 'https://flagcdn.com/w320/pt.png', code: 'PT' },
                    { name: 'Greece', lat: 39.0742, lon: 21.8243, flag: 'https://flagcdn.com/w320/gr.png', code: 'GR' },
                    { name: 'Czech Republic', lat: 49.8175, lon: 15.4730, flag: 'https://flagcdn.com/w320/cz.png', code: 'CZ' },
                    { name: 'Romania', lat: 45.9432, lon: 24.9668, flag: 'https://flagcdn.com/w320/ro.png', code: 'RO' },
                    { name: 'Ukraine', lat: 48.3794, lon: 31.1656, flag: 'https://flagcdn.com/w320/ua.png', code: 'UA' },
                    { name: 'Hungary', lat: 47.1625, lon: 19.5033, flag: 'https://flagcdn.com/w320/hu.png', code: 'HU' },
                    { name: 'Ireland', lat: 53.4129, lon: -8.2439, flag: 'https://flagcdn.com/w320/ie.png', code: 'IE' },
                    { name: 'Iceland', lat: 64.9631, lon: -19.0208, flag: 'https://flagcdn.com/w320/is.png', code: 'IS' }
                ];

                console.log(`${countries.length} pays de secours chargés`);
                return countries;
            }
        }

        // ========== GÉOLOCALISATION UTILISATEUR ==========

        function getUserLocation() {
            return new Promise((resolve) => {
                if ("geolocation" in navigator) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            userPosition.lat = position.coords.latitude;
                            userPosition.lon = position.coords.longitude;
                            console.log('Position utilisateur:', userPosition);
                            resolve(userPosition);
                        },
                        (error) => {
                            console.warn('Géolocalisation refusée, utilisation position par défaut (Paris)');
                            resolve(userPosition);
                        }
                    );
                } else {
                    console.warn('Géolocalisation non disponible');
                    resolve(userPosition);
                }
            });
        }

        // ========== CRÉATION SCÈNE BABYLON ==========

        async function createScene() {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.15);

            // Caméra avec contrôles arc-rotate pour faire pivoter la Terre
            camera = new BABYLON.ArcRotateCamera(
                "camera",
                Math.PI / 2,
                Math.PI / 2,
                5,
                BABYLON.Vector3.Zero(),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 3;
            camera.upperRadiusLimit = 10;

            // Ajuster le clipping pour éviter que les drapeaux disparaissent en zoomant
            camera.minZ = 0.01; // Near clipping plane très proche
            camera.maxZ = 1000; // Far clipping plane très loin

            // Lumières - éclairage ambiant pour voir toute la sphère
            const light1 = new BABYLON.HemisphericLight(
                "light1",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            light1.intensity = 1.0;

            const light2 = new BABYLON.PointLight(
                "light2",
                new BABYLON.Vector3(5, 5, 5),
                scene
            );
            light2.intensity = 0.3;

            // Lumière ambiante pour éclairer toute la scène uniformément
            const ambientLight = new BABYLON.HemisphericLight(
                "ambientLight",
                new BABYLON.Vector3(0, -1, 0),
                scene
            );
            ambientLight.intensity = 0.6;

            // Créer la sphère terrestre
            createEarth();

            // Attendre les données des pays
            await fetchCountries();
            await getUserLocation();

            // Créer les marqueurs de pays
            createCountryMarkers();

            // Créer le marqueur utilisateur
            createUserMarker();

            // Initialiser Leaflet
            initLeaflet();

            // Ajouter les pays sur Leaflet
            addCountriesToLeaflet();

            // Activer le picking (clic sur les objets 3D)
            enablePicking();

            loadingDiv.style.display = 'none';

            return scene;
        }

        // ========== CRÉATION TERRE ==========

        function createEarth() {
            // Sphère de rayon 2
            earth = BABYLON.MeshBuilder.CreateSphere(
                "earth",
                { diameter: 4, segments: 64 },
                scene
            );

            // Matériau avec texture de la Terre
            const earthMaterial = new BABYLON.StandardMaterial("earthMat", scene);

            // Texture de la Terre (nouvelle URL fournie)
            earthMaterial.diffuseTexture = new BABYLON.Texture(
                "https://raw.githubusercontent.com/turban/webgl-earth/master/images/2_no_clouds_4k.jpg",
                scene
            );

            // Inverser la texture verticalement (V scale et U scale négatif) pour corriger nord/sud
            earthMaterial.diffuseTexture.vScale = -1;
            earthMaterial.diffuseTexture.uScale = -1;

            earthMaterial.specularColor = new BABYLON.Color3(0.2, 0.2, 0.3);
            earth.material = earthMaterial;
        }

        // ========== MARQUEURS PAYS ==========

        function createCountryMarkers() {
            console.log('Création des marqueurs pour', countries.length, 'pays');

            countries.forEach((country, index) => {
                const radius = 2.12; // Au-dessus de la surface pour être visible
                const pos = latLonToCartesian(country.lat, country.lon, radius);

                // Créer un plan avec le drapeau directement
                const flagPlane = BABYLON.MeshBuilder.CreatePlane(
                    `flag_${country.code}`,
                    { width: 0.1, height: 0.075 }, // Réduit encore de 50%
                    scene
                );

                flagPlane.position = new BABYLON.Vector3(pos.x, pos.y, pos.z);

                // Orienter le plan vers la caméra (billboard mode)
                flagPlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

                // Matériau avec texture du drapeau
                const flagMaterial = new BABYLON.StandardMaterial(`flagMat_${country.code}`, scene);

                // Texture du drapeau
                const flagTexture = new BABYLON.Texture(country.flag, scene, false, false);

                // Inverser verticalement la texture du drapeau pour corriger l'orientation
                flagTexture.vScale = -1;

                flagMaterial.diffuseTexture = flagTexture;
                flagMaterial.emissiveTexture = flagTexture; // Pour être visible même sans lumière directe
                flagMaterial.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                flagMaterial.backFaceCulling = false;
                flagMaterial.useAlphaFromDiffuseTexture = true;

                flagPlane.material = flagMaterial;

                // Stocker les données du pays
                flagPlane.countryData = country;
                countryMarkers.push(flagPlane);
            });

            console.log(`${countryMarkers.length} drapeaux créés pour ${countries.length} pays`);
        }

        // ========== MARQUEUR UTILISATEUR ==========

        function createUserMarker() {
            const radius = 2.1;
            const pos = latLonToCartesian(userPosition.lat, userPosition.lon, radius);

            // Sphère rouge pour l'utilisateur
            userMarker3D = BABYLON.MeshBuilder.CreateSphere(
                "userMarker",
                { diameter: 0.15 },
                scene
            );

            userMarker3D.position = new BABYLON.Vector3(pos.x, pos.y, pos.z);

            const userMat = new BABYLON.StandardMaterial("userMat", scene);
            userMat.emissiveColor = new BABYLON.Color3(1, 0, 0);
            userMat.diffuseColor = new BABYLON.Color3(1, 0, 0);
            userMarker3D.material = userMat;

            // Animation pulsation
            let scale = 1;
            let growing = true;
            scene.registerBeforeRender(() => {
                if (growing) {
                    scale += 0.01;
                    if (scale >= 1.3) growing = false;
                } else {
                    scale -= 0.01;
                    if (scale <= 1) growing = true;
                }
                userMarker3D.scaling = new BABYLON.Vector3(scale, scale, scale);
            });
        }

        // ========== AJOUTER PAYS SUR LEAFLET ==========

        function addCountriesToLeaflet() {
            countries.forEach(country => {
                const marker = L.marker([country.lat, country.lon], {
                    title: country.name
                }).addTo(leafletMap);

                marker.bindPopup(`
                    <b>${country.name}</b><br>
                    <img src="${country.flag}" width="60"><br>
                    Lat: ${country.lat.toFixed(2)}, Lon: ${country.lon.toFixed(2)}
                `);
            });
        }

        // ========== PICKING (CLIC SUR OBJETS 3D) ==========

        function enablePicking() {
            scene.onPointerDown = (evt, pickResult) => {
                if (pickResult.hit) {
                    // Si on clique sur un marqueur de pays
                    if (pickResult.pickedMesh.countryData) {
                        const country = pickResult.pickedMesh.countryData;

                        console.log('Pays cliqué:', country.name);

                        // Recentrer la carte Leaflet sur ce pays
                        leafletMap.setView([country.lat, country.lon], 6);

                        // Afficher un popup
                        L.popup()
                            .setLatLng([country.lat, country.lon])
                            .setContent(`
                                <b>${country.name}</b><br>
                                <img src="${country.flag}" width="80">
                            `)
                            .openOn(leafletMap);

                        // Mettre à jour l'info
                        infoDiv.innerHTML = `
                            <strong>Pays sélectionné:</strong><br>
                            ${country.name}<br>
                            Lat: ${country.lat.toFixed(2)}, Lon: ${country.lon.toFixed(2)}
                        `;
                    }
                    // Si on clique sur la sphère terrestre elle-même
                    else if (pickResult.pickedMesh === earth && pickResult.pickedPoint) {
                        const point = pickResult.pickedPoint;
                        const latLon = cartesianToLatLon(point.x, point.y, point.z, 2);

                        console.log('Clic sur Terre:', latLon);

                        // Recentrer la carte Leaflet sur ce point
                        leafletMap.setView([latLon.lat, latLon.lon], 5);

                        // Ajouter un marqueur temporaire
                        L.marker([latLon.lat, latLon.lon])
                            .addTo(leafletMap)
                            .bindPopup(`Lat: ${latLon.lat.toFixed(2)}, Lon: ${latLon.lon.toFixed(2)}`)
                            .openPopup();

                        // Mettre à jour l'info
                        infoDiv.innerHTML = `
                            <strong>Point cliqué:</strong><br>
                            Lat: ${latLon.lat.toFixed(2)}<br>
                            Lon: ${latLon.lon.toFixed(2)}
                        `;
                    }
                }
            };
        }

        // ========== ROTATION CAMÉRA VERS POINT ==========

        function rotateCameraToPoint(lat, lon) {
            // Calculer les angles alpha et beta pour orienter la caméra
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lon + 180) * Math.PI / 180;

            // Animation smooth vers la nouvelle position
            BABYLON.Animation.CreateAndStartAnimation(
                'camAlpha',
                camera,
                'alpha',
                60,
                60,
                camera.alpha,
                theta,
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );

            BABYLON.Animation.CreateAndStartAnimation(
                'camBeta',
                camera,
                'beta',
                60,
                60,
                camera.beta,
                phi,
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );
        }

        // ========== DÉMARRAGE ==========

        (async () => {
            scene = await createScene();

            engine.runRenderLoop(() => {
                scene.render();
            });

            window.addEventListener('resize', () => {
                engine.resize();
            });

            // Support pour les orientations mobiles
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    engine.resize();
                    if (leafletMap) {
                        leafletMap.invalidateSize();
                    }
                }, 100);
            });

            // Désactiver le zoom pinch sur mobile pour éviter les conflits
            document.addEventListener('gesturestart', (e) => {
                e.preventDefault();
            });
        })();
    </script>
</body>
</html>
